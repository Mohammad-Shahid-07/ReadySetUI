
import { NextRequest, NextResponse } from "next/server";
import JSZip from "jszip";
import fs from "fs/promises";
import path from "path";
import { siteRegistry } from "@/lib/registry";

// Helper to read a file safely
async function readFileSafe(filePath: string): Promise<string | null> {
    try {
        return await fs.readFile(filePath, "utf-8");
    } catch (error) {
        return null;
    }
}

// Helper to recursively read a directory
async function readDirRecursive(dir: string, baseDir: string = dir): Promise<{ path: string; content: string }[]> {
    const results: { path: string; content: string }[] = [];
    try {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                results.push(...(await readDirRecursive(fullPath, baseDir)));
            } else {
                const content = await fs.readFile(fullPath, "utf-8");
                const relativePath = path.relative(baseDir, fullPath);
                results.push({ path: relativePath, content });
            }
        }
    } catch (e) {
        console.error(`Error reading directory ${dir}:`, e);
    }
    return results;
}

export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ site: string }> }
) {
    const { site } = await params;

    if (!siteRegistry[site]) {
        return NextResponse.json({ error: "Site not found" }, { status: 404 });
    }

    const zip = new JSZip();
    const projectRoot = process.cwd();

    // 1. Package.json
    const packageJsonContent = await readFileSafe(path.join(projectRoot, "package.json"));
    if (packageJsonContent) {
        const pkg = JSON.parse(packageJsonContent);
        pkg.name = site;
        pkg.description = `Standalone version of ${site}`;
        // Remove internal scripts if any, keep standard ones
        pkg.scripts = {
            dev: "next dev",
            build: "next build",
            start: "next start",
            lint: "eslint"
        };
        zip.file("package.json", JSON.stringify(pkg, null, 2));
    }

    // 2. Config files
    const configFiles = [
        "tsconfig.json",
        "next.config.ts",
        "postcss.config.mjs",
        "eslint.config.mjs",
        ".gitignore"
    ];

    for (const file of configFiles) {
        const content = await readFileSafe(path.join(projectRoot, file));
        if (content) {
            zip.file(file, content);
        }
    }

    // 3. App Directory
    // Read site files first as we need them for layout and page generation
    const siteComponentsPath = path.join(projectRoot, "components", site);
    const siteFiles = await readDirRecursive(siteComponentsPath);

    // Check if site has a layout.tsx
    let siteLayoutPath = "";
    const siteLayoutFile = siteFiles.find(f => f.path === "layout.tsx");

    if (siteLayoutFile) {
        // We will rename it to SiteLayout.tsx in components to avoid conflict
        // and to be easily imported.
        siteLayoutPath = "SiteLayout";
    }

    // Create app/layout.tsx
    const layoutContent = `import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
${siteLayoutPath ? `import SiteLayout from "@/components/SiteLayout";` : ""}

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "${site}",
  description: "Generated by Ready Set UI",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={\`\${geistSans.variable} \${geistMono.variable} antialiased\`}
      >
        ${siteLayoutPath ? `<SiteLayout>{children}</SiteLayout>` : "{children}"}
      </body>
    </html>
  );
}
`;
    zip.file("app/layout.tsx", layoutContent);

    // Copy globals.css
    const globalsCss = await readFileSafe(path.join(projectRoot, "app/globals.css"));
    if (globalsCss) {
        zip.file("app/globals.css", globalsCss);
    }

    // Create page.tsx
    // Find the likely entry point (LandingPage.tsx or similar)
    let entryComponent = "LandingPage";
    if (!siteFiles.find(f => f.path === "LandingPage.tsx")) {
        // Fallback: take the first file that looks like a component
        const likely = siteFiles.find(f => f.path.endsWith(".tsx") && !f.path.includes("Provider") && f.path !== "layout.tsx");
        if (likely) {
            entryComponent = likely.path.replace(".tsx", "");
        }
    }

    const pageContent = `import ${entryComponent} from "@/components/${entryComponent}";

export default function Home() {
  return <${entryComponent} />;
}
`;
    zip.file("app/page.tsx", pageContent);


    // 4. Components
    // Copy site components to components/ (root)
    // And update imports
    for (const file of siteFiles) {
        let content = file.content;
        let filePath = file.path;

        // Rename layout.tsx to SiteLayout.tsx if needed
        if (filePath === "layout.tsx") {
            filePath = "SiteLayout.tsx";
        }

        // Fix imports:
        // 1. Remove site-specific path: "@/components/uber-clone/..." -> "@/components/..."
        const siteImportRegex = new RegExp(`@/components/${site}/`, "g");
        content = content.replace(siteImportRegex, "@/components/");

        zip.file(path.join("components", filePath), content);
    }

    // 5. Shared Components (UI & Utils)
    // Copy components/ui
    const uiPath = path.join(projectRoot, "components", "ui");
    const uiFiles = await readDirRecursive(uiPath);
    for (const file of uiFiles) {
        zip.file(path.join("components/ui", file.path), file.content);
    }

    // Copy lib/utils.ts
    const utilsContent = await readFileSafe(path.join(projectRoot, "lib", "utils.ts"));
    if (utilsContent) {
        zip.file("lib/utils.ts", utilsContent);
    }

    // Copy SiteLink if used
    const siteLinkContent = await readFileSafe(path.join(projectRoot, "components", "site-link.tsx"));
    if (siteLinkContent) {
        zip.file("components/site-link.tsx", siteLinkContent);
    }

    // 6. Public Assets
    zip.folder("public");

    // Generate ZIP
    const zipContent = await zip.generateAsync({ type: "blob" });
    const arrayBuffer = await zipContent.arrayBuffer();

    return new NextResponse(arrayBuffer, {
        headers: {
            "Content-Type": "application/zip",
            "Content-Disposition": `attachment; filename="${site}-source.zip"`,
        },
    });
}
