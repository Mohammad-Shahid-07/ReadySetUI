import { NextRequest, NextResponse } from "next/server";
import JSZip from "jszip";
import fs from "fs/promises";
import path from "path";
import { siteRegistry } from "@/lib/registry";

// Helper to read a file safely
async function readFileSafe(filePath: string): Promise<string | null> {
    try {
        return await fs.readFile(filePath, "utf-8");
    } catch (error) {
        return null;
    }
}

// Helper to recursively read a directory
async function readDirRecursive(dir: string, baseDir: string = dir): Promise<{ path: string; content: string }[]> {
    const results: { path: string; content: string }[] = [];
    try {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                results.push(...(await readDirRecursive(fullPath, baseDir)));
            } else {
                const content = await fs.readFile(fullPath, "utf-8");
                const relativePath = path.relative(baseDir, fullPath);
                results.push({ path: relativePath, content });
            }
        }
    } catch (e) {
        console.error(`Error reading directory ${dir}:`, e);
    }
    return results;
}

export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ site: string }> }
) {
    const { site } = await params;

    if (!siteRegistry[site]) {
        return NextResponse.json({ error: "Site not found" }, { status: 404 });
    }

    const zip = new JSZip();
    const projectRoot = process.cwd();

    // 1. Package.json
    const packageJsonContent = await readFileSafe(path.join(projectRoot, "package.json"));
    if (packageJsonContent) {
        const pkg = JSON.parse(packageJsonContent);
        pkg.name = site;
        pkg.description = `Standalone version of ${site}`;
        // Remove internal scripts if any, keep standard ones
        pkg.scripts = {
            dev: "next dev",
            build: "next build",
            start: "next start",
            lint: "eslint"
        };
        zip.file("package.json", JSON.stringify(pkg, null, 2));
    }

    // 2. Config files
    const configFiles = [
        "tsconfig.json",
        "next.config.ts",
        "postcss.config.mjs",
        "eslint.config.mjs",
        ".gitignore"
    ];

    for (const file of configFiles) {
        const content = await readFileSafe(path.join(projectRoot, file));
        if (content) {
            zip.file(file, content);
        }
    }

    // 3. App Directory
    // Create layout.tsx
    const layoutContent = `import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "${site}",
  description: "Generated by Ready Set UI",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={\`\${geistSans.variable} \${geistMono.variable} antialiased\`}
      >
        {children}
      </body>
    </html>
  );
}
`;
    zip.file("app/layout.tsx", layoutContent);

    // Copy globals.css
    const globalsCss = await readFileSafe(path.join(projectRoot, "app/globals.css"));
    if (globalsCss) {
        zip.file("app/globals.css", globalsCss);
    }

    // Create page.tsx
    // We assume the main component is LandingPage.tsx for simplicity in this generic generator,
    // or we check what's in the folder.
    // For a robust solution, we'd parse registry.ts, but here we'll assume the user follows the convention:
    // components/[site]/LandingPage.tsx is the entry.
    // If not, we'll try to find index.tsx or page.tsx or similar.

    // Actually, let's look at what files are in components/[site]
    const siteComponentsPath = path.join(projectRoot, "components", site);
    const siteFiles = await readDirRecursive(siteComponentsPath);

    // Find the likely entry point (LandingPage.tsx or similar)
    // The registry says: "home": dynamic(() => import("@/components/uber-clone/LandingPage"))
    // We can try to guess it's LandingPage.tsx
    let entryComponent = "LandingPage";
    if (!siteFiles.find(f => f.path === "LandingPage.tsx")) {
        // Fallback: take the first file that looks like a component
        const likely = siteFiles.find(f => f.path.endsWith(".tsx") && !f.path.includes("Provider"));
        if (likely) {
            entryComponent = likely.path.replace(".tsx", "");
        }
    }

    const pageContent = `import ${entryComponent} from "@/components/${entryComponent}";

export default function Home() {
  return <${entryComponent} />;
}
`;
    zip.file("app/page.tsx", pageContent);


    // 4. Components
    // Copy site components to components/ (root)
    // And update imports
    for (const file of siteFiles) {
        let content = file.content;

        // Fix imports:
        // 1. Remove site-specific path: "@/components/uber-clone/..." -> "@/components/..."
        // Regex to replace @/components/[site]/X with @/components/X
        const siteImportRegex = new RegExp(`@/components/${site}/`, "g");
        content = content.replace(siteImportRegex, "@/components/");

        // 2. Fix relative imports if they were relying on being in the same folder?
        // If they were in the same folder, they use "./Foo". 
        // Since we are flattening/keeping the structure relative to components/, "./Foo" still works 
        // IF we keep the internal structure of components/[site] as components/.
        // Yes, we are moving components/[site]/* to components/*.

        // 3. Fix SiteLink? 
        // The standalone app might not have the complex routing. 
        // But we should copy SiteLink or replace it with next/link.
        // User said "change a few things".
        // If we copy SiteLink, it needs to work.
        // Let's copy SiteLink to components/site-link.tsx and ensure it works or simplify it.

        zip.file(path.join("components", file.path), content);
    }

    // 5. Shared Components (UI & Utils)
    // Copy components/ui
    const uiPath = path.join(projectRoot, "components", "ui");
    const uiFiles = await readDirRecursive(uiPath);
    for (const file of uiFiles) {
        zip.file(path.join("components/ui", file.path), file.content);
    }

    // Copy lib/utils.ts
    const utilsContent = await readFileSafe(path.join(projectRoot, "lib", "utils.ts"));
    if (utilsContent) {
        zip.file("lib/utils.ts", utilsContent);
    }

    // Copy SiteLink if used
    const siteLinkContent = await readFileSafe(path.join(projectRoot, "components", "site-link.tsx"));
    if (siteLinkContent) {
        // We might want to simplify SiteLink for the standalone app since it doesn't need subdomain logic
        // But keeping it as is usually doesn't hurt if it defaults to standard behavior.
        zip.file("components/site-link.tsx", siteLinkContent);
    }

    // 6. Public Assets
    // Copy public folder (optional but good)
    // For now, let's skip deep public copying to save time/bandwidth unless requested, 
    // but we should at least create the folder.
    zip.folder("public");


    // Generate ZIP
    const zipContent = await zip.generateAsync({ type: "blob" });
    const arrayBuffer = await zipContent.arrayBuffer();

    return new NextResponse(arrayBuffer, {
        headers: {
            "Content-Type": "application/zip",
            "Content-Disposition": `attachment; filename="${site}-source.zip"`,
        },
    });
}
